using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;

namespace Mossharbor.ActivityStreams.Security
{
    /// <summary>
    /// A linked data proof is comprised of information about the proof, parameters required to verify it, and the proof value itself.
    /// </summary>
    /// <see cref="https://w3c-ccg.github.io/ld-proofs/#verification-attributes"/>
    public class ProofBase : SecurityObjectBase, ICustomParser
    {
        /// <summary>
        /// Type String
        /// </summary>
        public static string ProofBaseType = "proof";

        /// <summary>
        /// Constructor
        /// </summary>
        public ProofBase() : base(ProofBase.ProofBaseType) { }

        /// <summary>
        /// Constructor
        /// </summary>
        public ProofBase(string baseType) : base(baseType) { }

        /// <summary>
        /// The type of proof
        /// </summary>
        public string ProofType { get; set; }

        /// <summary>
        /// Required. The specific intent for the proof, the reason why an entity created it.
        /// Acts as a safeguard to prevent the proof from being misused for a purpose other than the one it was intended for. 
        /// For example, a proof can be used for purposes of authentication, for asserting control of a Verifiable Credential (assertionMethod), and several others.
        /// </summary>
        public string ProofPurpose { get; set; }

        /// <summary>
        /// Required. A set of parameters required to independently verify the proof, such as an identifier for a public/private key pair that would be used in the proof.
        /// </summary>
        public string VerifcationMethod { get; set; }

        /// <summary>
        /// A random or pseudo-random value used by some authentication protocols to mitigate replay attacks
        /// </summary>
        public string Challenge { get; set; }

        /// <summary>
        /// The string value of an [ISO8601] combined date and time string generated by the Proof
        /// </summary>
        public DateTime? Created { get; set; }

        /// <summary>
        /// Optional. A string value specifying the restricted domain of the proof.
        /// </summary>
        public string Domain { get; set; }

        /// <summary>
        /// Required. One of any number of valid representations of proof value generated by the Proof Algorithm. Example: jws for detached JSON Web Signatures.
        /// </summary>
        public string ProofValue { get; set; }

        /// <inheritdoc/>
        public override void PerformCustomParsing(JsonElement el)
        {
            var type = el.GetStringOrDefault("type");
            if (null == type)
                type = el.GetStringOrDefault("@type");

            base.PerformCustomParsing(el);

            var proofPurpose = el.GetStringOrDefault("proofPurpose");
            var created = el.GetDateTimeOrDefault("created");
            var verificationMethod = el.GetStringOrDefault("verificationMethod");
            var challenge = el.GetStringOrDefault("challenge");
            var domain = el.GetStringOrDefault("domain");
            var proofValue = el.GetStringOrDefault("jws"); // TODO figure out how to make this more flexible

            this.Created = created;
            this.ProofType = type;
            this.ProofPurpose = proofPurpose;
            this.VerifcationMethod = verificationMethod;
            this.Challenge = challenge;
            this.Domain = domain;
            this.ProofValue = proofValue;
        }
    }
}
